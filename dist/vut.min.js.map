{"version":3,"file":"vut.min.js","sources":["../src/util.js","../src/vut.js"],"sourcesContent":["const util = {\n  isObject (obj) {\n    return !!obj && Object.prototype.toString.call(obj) === '[object Object]'\n  },\n  error (msg) {\n    throw new Error(`[Vut] ${msg}`)\n  },\n  has (obj, attr) {\n    return Object.prototype.hasOwnProperty.call(obj, attr)\n  },\n  callHook (vut, goods, name) {\n    vut.plugins.forEach(plugin => {\n      if (!util.has(plugin, name)) return\n      plugin[name].call(goods)\n    })\n  }\n}\n\nexport default util\n","import util from './util'\n\nclass Vut {\n  constructor () {\n    this.store = {}\n    this.plugins = []\n  }\n  use (plugin, options) {\n    if (Object.keys(this.store).length) {\n      util.error(`plugin must in create store before call`)\n    }\n    if (typeof plugin !== 'function') {\n      util.error(`plugin not is function type`)\n    }\n    const mixin = plugin(this, options)\n    if (!util.isObject(mixin)) {\n      util.error(`plugin return value not is object type`)\n    }\n    this.plugins.push(mixin)\n    return this\n  }\n  create (name, options) {\n    if (typeof name !== 'string') {\n      util.error(`'name' not is string type`)\n    }\n    if (!util.isObject(options)) {\n      util.error(`'options' not is object type`)\n    }\n    if (util.has(this.store, name)) {\n      util.error(`'${name}' already is in store`)\n    }\n    if (typeof options.data !== 'function') {\n      util.error(`'${name}' not is function type`)\n    }\n    const goods = Object.create(null)\n    goods.$options = options\n    util.callHook(this, goods, 'beforeCreate')\n    // Bind methods\n    Object.keys(goods.$options).forEach(fnName => {\n      goods[fnName] = function action () {\n        const res = goods.$options[fnName].apply(goods, arguments)\n        return res\n      }\n    })\n    // Compression path\n    goods.$state = goods.data()\n    if (!util.isObject(goods.$state)) {\n      util.error(`'${name}' return value not is object type`)\n    }\n    Object.keys(goods.$state).forEach(attrName => {\n      Object.defineProperty(goods, attrName, {\n        get () {\n          return goods.$state[attrName]\n        },\n        set (val) {\n          goods.$state[attrName] = val\n        }\n      })\n    })\n    this.store[name] = goods\n    util.callHook(this, goods, 'created')\n    return this\n  }\n  destroy () {\n    Object.keys(this.store).forEach(goods => {\n      util.callHook(this, this.store[goods], 'beforeDestroy')\n      util.callHook(this, this.store[goods], 'destroyed')\n    })\n    return this\n  }\n}\n\nObject.assign(Vut, {\n  util\n})\n\nexport default Vut\n"],"names":["util","obj","Object","prototype","toString","call","msg","Error","attr","hasOwnProperty","vut","goods","name","plugins","forEach","has","plugin","Vut","store","options","keys","this","length","error","mixin","isObject","push","data","create","$options","callHook","fnName","apply","arguments","$state","defineProperty","attrName","val","_this","assign"],"mappings":"+KAAA,IAAMA,qBACMC,WACCA,GAA+C,oBAAxCC,OAAOC,UAAUC,SAASC,KAAKJ,mBAE1CK,SACC,IAAIC,eAAeD,iBAEtBL,EAAKO,UACDN,OAAOC,UAAUM,eAAeJ,KAAKJ,EAAKO,sBAEzCE,EAAKC,EAAOC,KAChBC,QAAQC,QAAQ,YACbd,EAAKe,IAAIC,EAAQJ,MACfA,GAAMP,KAAKM,uvCCXlBM,yCAEGC,cACAL,iDAEFG,EAAQG,GACPjB,OAAOkB,KAAKC,KAAKH,OAAOI,UACrBC,iDAEe,mBAAXP,KACJO,yCAEDC,EAAQR,EAAOK,KAAMF,UACtBnB,EAAKyB,SAASD,MACZD,qDAEFV,QAAQa,KAAKF,GACXH,oCAEDT,EAAMO,GACQ,iBAATP,KACJW,mCAEFvB,EAAKyB,SAASN,MACZI,sCAEHvB,EAAKe,IAAIM,KAAKH,MAAON,MAClBW,UAAUX,2BAEW,mBAAjBO,EAAQQ,QACZJ,UAAUX,gCAEXD,EAAQT,OAAO0B,OAAO,eACtBC,SAAWV,IACZW,SAAST,KAAMV,EAAO,uBAEpBS,KAAKT,EAAMkB,UAAUf,QAAQ,cAC5BiB,GAAU,kBACFpB,EAAMkB,SAASE,GAAQC,MAAMrB,EAAOsB,gBAK9CC,OAASvB,EAAMgB,OAChB3B,EAAKyB,SAASd,EAAMuB,WAClBX,UAAUX,8CAEVQ,KAAKT,EAAMuB,QAAQpB,QAAQ,mBACzBqB,eAAexB,EAAOyB,yBAElBzB,EAAMuB,OAAOE,iBAEjBC,KACGH,OAAOE,GAAYC,YAI1BnB,MAAMN,GAAQD,IACdmB,SAAST,KAAMV,EAAO,WACpBU,gEAGAD,KAAKC,KAAKH,OAAOJ,QAAQ,cACzBgB,WAAeQ,EAAKpB,MAAMP,GAAQ,mBAClCmB,WAAeQ,EAAKpB,MAAMP,GAAQ,eAElCU,qBAIXnB,OAAOqC,OAAOtB"}