{"version":3,"file":"vut.min.js","sources":["../src/util.js","../src/vut.js"],"sourcesContent":["import Vut from './vut'\n\nconst util = {\n  isObject (obj) {\n    return !!obj && Object.prototype.toString.call(obj) === '[object Object]'\n  },\n  error (msg) {\n    throw new Error(`[vut] ${msg}`)\n  },\n  has (obj, attr) {\n    return Object.prototype.hasOwnProperty.call(obj, attr)\n  },\n  pathCompression (obj, options) {\n    Object.keys(options).forEach(k => {\n      Object.defineProperty(obj, k, {\n        get () {\n          return options[k]\n        },\n        set (val) {\n          options[k] = val\n        }\n      })\n    })\n  },\n  getModule (vut, paths, fn) {\n    if (typeof paths === 'string') {\n      if (!util.has(vut.modules, paths)) {\n        util.error(`Module '${paths}' does not exist`)\n      }\n      return fn(vut.modules[paths])\n    } else if (util.isObject(paths)) {\n      const data = {}\n      Object.keys(paths).forEach(name => {\n        if (!util.has(vut.modules, name)) {\n          util.error(`Module '${paths[name]}' does not exist`)\n        }\n        data[name] = fn(vut.modules[paths[name]])\n      })\n      return data\n    }\n    util.error(`The parameter is illegal. Please use 'vut.getModule(path: string)' or 'vut.getModule({ [path: string]: string })'`)\n  },\n  callModuleHook (vut, goods, name, ...arg) {\n    const mixins = Vut\n      .options\n      .plugins\n      .filter(plugin => {\n        return util.isObject(plugin.module)\n      })\n      .map(plugin => plugin.module)\n    mixins.forEach(mixin => {\n      if (!util.has(mixin, name)) return\n      mixin[name].apply(goods, arg)\n    })\n  },\n  callInstanceHook (vut, name, ...arg) {\n    const mixins = Vut\n      .options\n      .plugins\n      .filter(plugin => {\n        return util.isObject(plugin.instance)\n      })\n      .map(plugin => plugin.instance)\n    mixins.forEach(mixin => {\n      if (!util.has(mixin, name)) return\n      mixin[name].apply(vut, arg)\n    })\n  }\n}\n\nexport default util\n","import util from './util'\n\nlet isUse = false\n\nclass Vut {\n  constructor (options) {\n    this.modules = {}\n    this.plugins = []\n    util.callInstanceHook(this, 'beforeCreate')\n    util.callInstanceHook(this, 'created')\n    isUse = true\n  }\n  addModules (path, moduleOptions) {\n    if (typeof path !== 'string') {\n      util.error(`'path=${path}' not is string type`)\n    }\n    if (!path) {\n      util.error(`'path' not is null string`)\n    }\n    if (!util.isObject(moduleOptions)) {\n      util.error(`${path} 'options' not is object type`)\n    }\n    if (util.isObject(moduleOptions.modules)) {\n      Object.keys(moduleOptions.modules).forEach(k => {\n        this.addModules(`${path}/${k}`, moduleOptions.modules[k])\n      })\n    }\n    if (util.has(this.modules, path)) {\n      util.error(`'${path}' already is in module`)\n    }\n    if (typeof moduleOptions.data !== 'function') {\n      util.error(`'${path}' not is function type`)\n    }\n    const goods = Object.create(null)\n    goods.$options = moduleOptions\n    goods.$context = this\n    util.callModuleHook(this, goods, 'beforeCreate')\n\n    // Bind action\n    goods.$actions = {}\n    Object.keys(goods.$options).forEach(fnName => {\n      if (typeof goods.$options[fnName] !== 'function') return\n      goods.$actions[fnName] = function action () {\n        util.callModuleHook(this, goods, 'beforeAction', fnName)\n        const res = goods.$options[fnName].apply(goods, arguments)\n        util.callModuleHook(this, goods, 'actioned', fnName, res)\n        return res\n      }\n    })\n\n    // Bind state\n    goods.$state = goods.$actions.data()\n    if (!util.isObject(goods.$state)) {\n      util.error(`'vut.getAction(${path}).data()' return value not is object type`)\n    }\n\n    // Path compression\n    util.pathCompression(goods, goods.$actions)\n    util.pathCompression(goods, goods.$state)\n\n    this.modules[path] = goods\n    util.callModuleHook(this, goods, 'created')\n    return this\n  }\n  getModule (paths) {\n    return util.getModule(this, paths, goods => goods)\n  }\n  getState (paths) {\n    return util.getModule(this, paths, goods => goods.$state)\n  }\n  getActions (paths) {\n    return util.getModule(this, paths, goods => goods.$actions)\n  }\n  destroy () {\n    util.callInstanceHook(this, 'beforeDestroy')\n    Object.keys(this.modules).forEach(path => {\n      const goods = this.modules[path]\n      util.callModuleHook(this, goods, 'beforeDestroy')\n      util.callModuleHook(this, goods, 'destroyed')\n    })\n    util.callInstanceHook(this, 'destroyed')\n    return this\n  }\n}\n\nObject.assign(Vut, {\n  options: {\n    plugins: []\n  },\n  use (plugin) {\n    if (!util.isObject(plugin)) {\n      util.error(`plugin not is object type`)\n    }\n    if (isUse) {\n      return util.error(`'Vut.use(plugin)' must in 'new Vut()' before`)\n    }\n    this.options.plugins.push(plugin)\n    return this\n  }\n})\n\nexport default Vut\n"],"names":["util","obj","Object","prototype","toString","call","msg","Error","attr","hasOwnProperty","options","keys","forEach","defineProperty","k","val","vut","paths","fn","has","modules","error","isObject","data","name","goods","arg","Vut","plugins","filter","plugin","module","map","mixin","apply","instance","isUse","callInstanceHook","this","path","moduleOptions","addModules","create","$options","$context","callModuleHook","$actions","fnName","res","arguments","$state","pathCompression","getModule","_this2","assign","push"],"mappings":"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"}